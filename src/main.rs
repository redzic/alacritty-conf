#![warn(clippy::all, clippy::pedantic, clippy::nursery)]
#![allow(clippy::missing_docs_in_private_items)]
#![feature(const_option)]

mod config;
mod theme;

use crate::config::{Config, PartialConfig};
use crate::theme::{ColorTheme, Font, FontSize, Invert, Theme, Window};
use std::fs::{self, File};
use std::io::{self, Write};
use structopt::clap::AppSettings::ColoredHelp;
use structopt::StructOpt;
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};

#[derive(Debug, StructOpt)]
#[structopt(setting = ColoredHelp)]
struct Args {
    /// Color theme. Use -l/--list-themes to view available themes.
    #[structopt()]
    theme: Option<ColorTheme>,

    // TODO check if it's a valid font before setting it
    /// Font family of terminal to set
    #[structopt(short, long)]
    font: Option<String>,

    /// Font size (integer)
    #[structopt(short = "s", long)]
    font_size: Option<u16>,

    /// Print all available themes
    #[structopt(short, long)]
    list_themes: bool,

    /// Invert colors of the selected theme
    #[structopt(short = "I", long)]
    invert_colors: bool,

    /// Dimensions of window size
    #[structopt(long, short, default_value = "80x25")]
    dimensions: Window,
}

fn main() -> Result<(), io::Error> {
    let args = Args::from_args();

    // TODO add information at the beginning of files
    // so that it can detect if the config file was originally
    // made by this program and use that to keep settings
    // not specified there

    let mut stdout = StandardStream::stdout(ColorChoice::Always);
    let mut stderr = StandardStream::stderr(ColorChoice::Always);

    if args.list_themes {
        writeln!(
            stdout,
            "\
afterglow
argonaut
ayu-dark
ayu-mirage
base16
breeze
dracula
kitty
gruvbox
material
monokai-soda"
        )?;

        stdout.flush()?;

        return Ok(());
    }

    // TODO do not crash if none is specified, just get the default one instead
    let theme = if let Some(theme_preset) = args.theme {
        let mut theme: Theme = theme_preset.into();

        if args.invert_colors {
            theme.invert();
        }

        theme
    } else {
        stderr.set_color(ColorSpec::new().set_fg(Some(Color::Red)).set_bold(true))?;
        write!(stderr, "error:")?;
        stderr.reset()?;
        write!(stderr, " You must provide a value for '")?;
        stderr.set_color(ColorSpec::new().set_fg(Some(Color::Yellow)))?;
        write!(stderr, "<theme>")?;
        stderr.reset()?;

        write!(stderr, "'\nUse ")?;
        stderr.set_color(ColorSpec::new().set_fg(Some(Color::Green)))?;
        write!(stderr, "-l")?;
        stderr.reset()?;
        write!(stderr, "/")?;
        stderr.set_color(ColorSpec::new().set_fg(Some(Color::Green)))?;
        write!(stderr, "--list-themes")?;
        stderr.reset()?;
        writeln!(stderr, " to view the available themes.")?;

        stderr.flush()?;

        std::process::exit(1);
    };

    let path = {
        let mut path = dirs::config_dir().unwrap();
        path.push("alacritty");
        path.push("alacritty.yml");
        path
    };

    // TODO: correct error handling
    let alacritty_yml_old = fs::read_to_string(&path)?;

    let mut alacritty_yml = File::create(&path)?;

    // TODO detect if the file does not already exist, and inform the user that
    // since it's the first time that they're creating the config, changes only
    // apply after restatring alacritty

    // TODO validate font

    write!(
        alacritty_yml,
        "# generated by alacritty-conf ({})\n\n{}",
        chrono::Utc::now().to_rfc2822(),
        {
            let old_config = config::parse(alacritty_yml_old.as_str());

            match old_config {
                Some(config) => config::merge(
                    PartialConfig::new(
                        match args.font {
                            Some(f) => Some(Font {
                                family: Some(f),
                                size: FontSize(
                                    args.font_size
                                        .unwrap_or_else(|| config.font_size_or_default()),
                                ),
                            }),
                            None => Some(Font {
                                family: match config.font() {
                                    // TODO make font family generic to avoid this mess
                                    Some(f) => f.family.as_ref().map(|f| f.as_str().to_owned()),
                                    None => None,
                                },
                                size: FontSize(
                                    args.font_size
                                        .unwrap_or_else(|| config.font_size_or_default()),
                                ),
                            }),
                        },
                        // TODO maybe these don't need to be wrapped in Option?
                        Some(theme),
                        Some(args.dimensions),
                    ),
                    config,
                ),
                None => Config::default(),
            }
        }
    )?;

    Ok(())
}
